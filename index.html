//@version=6
indicator("Rom Master - Multi-Pattern Strategy", overlay=true)

// ====================================
// 1. GLOBAL CONFIGURATION & GENERICS
// ====================================

// This block defines the user-adjustable execution rules for trade frequency and cooldown periods.
bool use_no_trade = input.bool(false, "BLOCK ENTRY IF TRADE ACTIVE?", group="═════ MANDATORY EXECUTION RULES ═════", tooltip="ON = Strictly 1 trade at a time.\nOFF = Allows unlimited trades (Stacking).")
bool show_low_profit = input.bool(true, "SHOW LOW PROFIT TRADES?", group="═════ MANDATORY EXECUTION RULES ═════", tooltip="ON = Shows all trades regardless of profit potential.\nOFF = Hides trades that do not meet the minimum profit threshold.")
bool use_cooldown = input.bool(false, "PAUSE AFTER TRADE (COOLDOWN)?", group="═════ MANDATORY EXECUTION RULES ═════", tooltip="ON = Wait for the 'Cooldown Bars' duration after a trade finishes before looking for new setups.")
int cooldown_bars = input.int(2, "Cooldown Duration (Bars)", group="═════ MANDATORY EXECUTION RULES ═════")

// This block handles money management inputs for share sizing, commission calculations, and the performance lookback window.
int trade_qty = input.int(250, "Trade Share Size", group="═════ MONEY MANAGEMENT ═════")
float commission_per_share = input.float(0.02, "Commission (Per Share - Round Trip)", group="═════ MONEY MANAGEMENT ═════", tooltip="Cost per share for a round-trip trade (buy + sell). Example: 0.02 means $50 commission for 2500 shares.")
int lookback_days = input.int(1, "Performance History (Days)", minval=1, group="═════ MONEY MANAGEMENT ═════", tooltip="Number of calendar days to track performance for. Set to 9999 to track all history.")

// This block calculates technical indicators including moving averages and volume metrics for trend and volatility analysis.
float vol_ma_10 = ta.sma(volume, 10)

// This logic calculates a session-based Volume Weighted Average Price (VWAP) that resets at the start of every trading day.
var float vwap_sum_src_vol = 0.0
var float vwap_sum_vol = 0.0

if ta.change(time("D")) != 0
    vwap_sum_src_vol := 0.0
    vwap_sum_vol := 0.0
    
vwap_sum_src_vol += hlc3 * volume
vwap_sum_vol += volume
float vwap_val = vwap_sum_src_vol / vwap_sum_vol

// This block initializes hardcoded MACD and EMA components used for momentum filtering across all patterns.
[macd_line, signal_line, macd_hist] = ta.macd(close, 12, 26, 9)
float ema_9 = ta.ema(close, 9)

// This logic tracks the highest price reached during the current trading session for Pattern 3 target calculations.
varip float daily_high = 0.0
bool new_day = ta.change(time("D")) != 0
if new_day
    daily_high := high
else
    daily_high := math.max(daily_high, high)

// This block defines a custom Trade object to store and manage entry, exit, and visual data for active positions.
type Trade
    float entry
    float sl
    float tp
    string pat
    line l_e
    line l_tp
    line l_sl
    box b_risk
    label lbl
    bool is_real 

// This section initializes persistence variables to lock trade parameters and prevent recalculation within the same bar.
varip bool p1_lock = false
varip float p1_lock_entry = 0.0
varip float p1_lock_sl = 0.0
varip float p1_lock_tp = 0.0
varip bool p1_lock_real = true 

varip bool p2_lock = false
varip float p2_lock_entry = 0.0
varip float p2_lock_sl = 0.0
varip float p2_lock_tp = 0.0
varip bool p2_lock_real = true 

varip bool p3_lock = false
varip float p3_lock_entry = 0.0
varip float p3_lock_sl = 0.0
varip float p3_lock_tp = 0.0

if barstate.isnew
    p1_lock := false
    p2_lock := false
    p3_lock := false

// This block establishes global arrays and counters for tracking active trades, profit/loss, and timing constraints.
var Trade[] active_trades = array.new<Trade>()
var int cnt_win = 0
var int cnt_loss = 0
var float net_profit = 0.0

var int last_exit_bar = -999
var int last_entry_bar = -999

var string status_txt = "Waiting"

// This block initializes arrays to store and manage visual objects like lines, boxes, and labels for chart display.
var line[] weekly_lines = array.new_line()
var box[] weekly_boxes = array.new_box()
var label[] weekly_labels = array.new_label()

// ====================================
// 2. PATTERN 1: BULL FLAG SETTINGS
// ====================================
// This section provides inputs for Pattern 1 to configure filter sensitivity and mandatory technical requirements.
bool p1_enabled = input.bool(true, "MASTER SWITCH: Enable Bull Flag", group="═════ PATTERN 1: BULL FLAG ═════")
int p1_allowed_fails = input.int(2, "Max Allowed Filter Failures", minval=0, group="═════ PATTERN 1: BULL FLAG ═════", tooltip="How many filters are allowed to fail while still triggering a buy (excluding Mandatory filters).")

bool p1_use_vwap = input.bool(true, "Filter: Price > VWAP? (MANDATORY)", group="═════ PATTERN 1: BULL FLAG ═════")
bool p1_use_macd = input.bool(true, "Filter: MACD > 0 & > Signal?", group="═════ PATTERN 1: BULL FLAG ═════")

// This block defines the structural constraints for Bull Flag detection including bar counts, EMA proximity, and volume ratios.
int p1_pole_min_bars = 2
int p1_flag_min_bars = 1
int p1_flag_max_bars = 5
bool p1_use_green = true
bool p1_strict_ema = input.bool(true, "Structure: Body > 9 EMA?", group="═════ PATTERN 1: BULL FLAG ═════")
bool p1_use_depth = input.bool(true, "Structure: Max Pullback Depth (50%)?", group="═════ PATTERN 1: BULL FLAG ═════")
bool p1_use_vol = input.bool(true, "Structure: Flag Vol < Pole Vol?", group="═════ PATTERN 1: BULL FLAG ═════")
bool p1_use_breakout_vol = input.bool(true, "Structure: Breakout Vol > Flag Vol?", group="═════ PATTERN 1: BULL FLAG ═════")

bool p1_avoid_wick = input.bool(true, "Structure: Avoid Pole Top Wick?", group="═════ PATTERN 1: BULL FLAG ═════")
float p1_wick_ratio = input.float(0.5, "Structure: Pole Wick Ratio", group="═════ PATTERN 1: BULL FLAG ═════")

// ====================================
// 3. PATTERN 2: ABCD SETTINGS
// ====================================
// This section sets the filtering thresholds and master toggle for the ABCD pattern detection logic.
bool p2_enabled = input.bool(true, "MASTER SWITCH: Enable ABCD", group="═════ PATTERN 2: ABCD ═════")
int p2_allowed_fails = input.int(2, "Max Allowed Filter Failures", minval=0, group="═════ PATTERN 2: ABCD ═════")

bool p2_use_vwap = input.bool(true, "Filter: Price > VWAP? (MANDATORY)", group="═════ PATTERN 2: ABCD ═════")
bool p2_use_macd = input.bool(true, "Filter: MACD > 0 & > Signal?", group="═════ PATTERN 2: ABCD ═════")

// This block configures the geometric and volume rules required to identify a valid ABCD harmonic structure.
bool p2_use_green = true
bool p2_strict_ema = input.bool(true, "Structure: Body > 9 EMA?", group="═════ PATTERN 2: ABCD ═════")
bool p2_use_depth = input.bool(true, "Structure: Max Pullback Depth (50%)?", group="═════ PATTERN 2: ABCD ═════")
bool p2_check_hod = true
bool p2_c_below_b = true
bool p2_use_vol = input.bool(true, "Structure: Pullback Vol < Surge Vol?", group="═════ PATTERN 2: ABCD ═════")
bool p2_use_breakout_vol = input.bool(true, "Structure: Breakout Vol > Pullback Vol?", group="═════ PATTERN 2: ABCD ═════")

// ====================================
// 4. PATTERN 3: VWAP BREAK SETTINGS
// ====================================
// This section manages the setup parameters and distance thresholds for the VWAP breakout pattern.
bool p3_enabled = input.bool(true, "MASTER SWITCH: Enable VWAP Break", group="═════ PATTERN 3: VWAP BREAK ═════")

int p3_bars_required = input.int(8, "Setup Bars Below VWAP", group="═════ PATTERN 3: VWAP BREAK ═════")
bool p3_use_macd = input.bool(true, "Filter: MACD Open? (Hard Switch)", group="═════ PATTERN 3: VWAP BREAK ═════")
float p3_gr_dist = input.float(0.10, "Get Ready Distance (Cents)", group="═════ PATTERN 3: VWAP BREAK ═════")
float p3_sl_dist = input.float(0.10, "Stop Loss Distance (Cents)", group="═════ PATTERN 3: VWAP BREAK ═════")

// ====================================
// 5. LOGIC: RESET MECHANISM
// ====================================
// This logic monitors the time and clears all historical statistics and visual objects when the lookback window starts.
int y = year(timenow, syminfo.timezone)
int m = month(timenow, syminfo.timezone)
int d = dayofmonth(timenow, syminfo.timezone)
int lookback_start_time = timestamp(syminfo.timezone, y, m, d - (lookback_days - 1), 0, 0, 0)

bool is_reset_bar = time[1] < lookback_start_time and time >= lookback_start_time

if is_reset_bar
    cnt_win := 0
    cnt_loss := 0
    net_profit := 0.0
    status_txt := "Waiting"
    last_exit_bar := -999
    last_entry_bar := -999
    active_trades.clear()
    while array.size(weekly_lines) > 0
        line.delete(array.pop(weekly_lines))
    while array.size(weekly_boxes) > 0
        box.delete(array.pop(weekly_boxes))
    while array.size(weekly_labels) > 0
        label.delete(array.pop(weekly_labels))

// ====================================
// 6. PATTERN RECOGNITION FUNCTIONS
// ====================================

// This function scans historical price and volume data to detect valid Bull Flag pole and flag formations.
find_bull_flag() =>
    float ret_sl = 0.0
    float ret_entry = 0.0
    float ret_flag_vol = 0.0
    bool ret_found = false
    int ret_fails = 0

    if p1_enabled
        for f_len = p1_flag_min_bars to p1_flag_max_bars
            int pole_end_idx = f_len + 1
            bool is_pole = true
            int current_p1_fails = 0
            int high_vol_count = 0
            for p = 0 to p1_pole_min_bars - 1
                int idx = pole_end_idx + p
                if close[idx] <= open[idx]
                    is_pole := false
                    break
                if volume[idx] > vol_ma_10[idx]
                    high_vol_count += 1
            if is_pole
                int vol_threshold = math.floor(p1_pole_min_bars / 2)
                if high_vol_count < vol_threshold
                    is_pole := false

            if is_pole and p1_avoid_wick
                float top_high = high[pole_end_idx]
                float top_open = open[pole_end_idx]
                float top_close = close[pole_end_idx]
                float u_wick = top_high - math.max(top_open, top_close)
                float body = math.abs(top_close - top_open)
                if u_wick > (body * p1_wick_ratio)
                    current_p1_fails += 1

            if is_pole
                float full_surge_high = high[pole_end_idx]
                float full_surge_low = low[pole_end_idx]
                float top_candle_vol = volume[pole_end_idx]
                float pole_vol_sum = 0.0
                int pole_bar_count = 0
                int scan_idx = pole_end_idx
                while close[scan_idx] > open[scan_idx]
                    if high[scan_idx] > full_surge_high
                        full_surge_high := high[scan_idx]
                    if low[scan_idx] < full_surge_low
                        full_surge_low := low[scan_idx]
                    pole_vol_sum += volume[scan_idx]
                    pole_bar_count += 1
                    scan_idx := scan_idx + 1
                    if scan_idx > pole_end_idx + 50
                        break
                bool is_valid_flag = true
                float lowest_flag_low = high
                float flag_vol_sum = 0.0
                float potential_entry = 0.0
                float potential_sl = 0.0
                bool has_green_tip = close[1] > open[1]
                if has_green_tip
                    if f_len < 2 or high[1] >= high[2]
                        is_valid_flag := false
                    else if p1_strict_ema and math.min(open[1], close[1]) < ema_9[1]
                        current_p1_fails += 1
                    if is_valid_flag
                        flag_vol_sum := volume[1]
                        lowest_flag_low := math.min(lowest_flag_low, low[1])
                        potential_entry := high[1]
                        potential_sl := low[1]
                        for k = 2 to f_len
                            if close[k] >= open[k]
                                is_valid_flag := false
                                break
                            if p1_strict_ema and math.min(open[k], close[k]) < ema_9[k]
                                current_p1_fails += 1
                            lowest_flag_low := math.min(lowest_flag_low, low[k])
                else
                    potential_entry := high[1]
                    potential_sl := low[1]
                    flag_vol_sum := volume[1]
                    for k = 1 to f_len
                        if close[k] >= open[k]
                            is_valid_flag := false
                            break
                        if p1_strict_ema and math.min(open[k], close[k]) < ema_9[k]
                            current_p1_fails += 1
                        lowest_flag_low := math.min(lowest_flag_low, low[k])
                if is_valid_flag
                    float pole_height = full_surge_high - full_surge_low
                    float pullback_depth = full_surge_high - lowest_flag_low
                    float depth_ratio = pole_height > 0 ? (pullback_depth / pole_height) : 1.0
                    float avg_pole_vol = pole_bar_count > 0 ? pole_vol_sum / pole_bar_count : 0.0
                    float avg_flag_vol = flag_vol_sum
                    bool vol_rule_passed = not p1_use_vol or (avg_flag_vol < avg_pole_vol or avg_flag_vol < top_candle_vol)
                    if not vol_rule_passed
                        current_p1_fails += 1
                    bool depth_rule_passed = not p1_use_depth or (depth_ratio <= 0.50)
                    if not depth_rule_passed
                        current_p1_fails += 1

                    ret_entry := potential_entry
                    ret_sl := potential_sl
                    ret_flag_vol := avg_flag_vol
                    ret_found := true
                    ret_fails := current_p1_fails
                    break

    [ret_found, ret_entry, ret_sl, ret_flag_vol, ret_fails]

// This function identifies the ABCD pattern by searching for a surge leg followed by specific retracement and consolidation points.
find_abcd() =>
    bool f_abcd = false
    float f_entry = 0.0
    float f_sl = 0.0
    float f_ref_vol = 0.0
    int ret_fails = 0
    int idx_user_a = 0
    int idx_user_b = 0
    int idx_user_c = 0

    if p2_enabled
        for len_c = 2 to 5
            bool is_c_valid = true
            float vol_sum_c = 0.0
            float low_c = low[1]
            int temp_idx_c = 1
            for k = 1 to len_c
                vol_sum_c += volume[k]
                if low[k] <= low_c
                    low_c := low[k]
                    temp_idx_c := k

            if is_c_valid
                int idx_b_start = len_c + 1
                for len_b = 1 to 5
                    int idx_b_end = idx_b_start + len_b - 1
                    bool is_b_valid = true
                    float high_b = 0.0
                    int temp_idx_b = idx_b_start
                    float vol_sum_b = 0.0
                    int current_p2_fails = 0
                    for k = idx_b_start to idx_b_end
                        if high[k] >= high_b
                            high_b := high[k]
                            temp_idx_b := k
                        vol_sum_b += volume[k]
                    if is_b_valid
                        for k = 1 to len_c
                            if high[k] >= high_b
                                is_b_valid := false
                                break

                    if is_b_valid
                        int idx_a_start = idx_b_end + 1
                        for len_a = 2 to 5
                            int idx_a_end = idx_a_start + len_a - 1
                            bool is_a_valid = true
                            float low_a = high[idx_a_start]
                            int temp_idx_a = idx_a_start
                            float vol_sum_a = 0.0
                            for k = idx_a_start to idx_a_end
                                if low[k] <= low_a
                                    low_a := low[k]
                                    temp_idx_a := k
                                vol_sum_a := vol_sum_a + volume[k]

                            if is_a_valid and low_c < low_a
                                is_a_valid := false
                            if is_a_valid and p2_strict_ema
                                if math.min(open[temp_idx_a], close[temp_idx_a]) < ema_9[temp_idx_a] or math.min(open[temp_idx_c], close[temp_idx_c]) < ema_9[temp_idx_c]
                                    current_p2_fails += 1

                            if is_a_valid
                                int idx_s_start = idx_a_end + 1
                                int surge_cnt = 0
                                float surge_high = 0.0
                                float surge_low = low[idx_s_start]
                                float vol_sum_surge = 0.0
                                float top_candle_vol = volume[idx_s_start]
                                int scan = idx_s_start
                                while close[scan] > open[scan] and scan < (idx_s_start + 10)
                                    surge_cnt += 1
                                    if high[scan] >= surge_high
                                        surge_high := high[scan]
                                        top_candle_vol := volume[scan]
                                    surge_low := math.min(surge_low, low[scan])
                                    vol_sum_surge += volume[scan]
                                    scan += 1
                                if surge_cnt >= 2
                                    if p2_check_hod and high_b > surge_high
                                        is_b_valid := false
                                    for k = idx_a_start to idx_a_end
                                        if high[k] >= surge_high
                                            is_b_valid := false
                                    for k = idx_b_start to idx_b_end
                                        if low[k] < low_a
                                            is_b_valid := false

                                    if is_b_valid
                                        float surge_height = surge_high - surge_low
                                        float a_depth = surge_high - low_a
                                        float depth_ratio = surge_height > 0 ? (a_depth / surge_height) : 1.0
                                        bool depth_ok = not p2_use_depth or (depth_ratio <= 0.50)
                                        if not depth_ok
                                            current_p2_fails += 1
                                        float avg_vol_surge = vol_sum_surge / surge_cnt
                                        float avg_vol_a = vol_sum_a / len_a
                                        bool vol_ok = not p2_use_vol or (avg_vol_a < avg_vol_surge or avg_vol_a < top_candle_vol)
                                        if not vol_ok
                                            current_p2_fails += 1
                                        f_abcd := true
                                        f_entry := high_b
                                        f_sl := low_c
                                        f_ref_vol := avg_vol_a
                                        idx_user_a := temp_idx_a
                                        idx_user_b := temp_idx_b
                                        idx_user_c := temp_idx_c
                                        ret_fails := current_p2_fails
                                        break
                        if f_abcd
                            break
                if f_abcd
                    break

    [f_abcd, f_entry, f_sl, f_ref_vol, idx_user_a, idx_user_b, idx_user_c, ret_fails]

// ====================================
// 7. SIGNAL AGGREGATION & FILTERING
// ====================================

// This block executes the pattern functions and calculates standardized trend and volume filters for signal validation.
[p1_found, p1_raw_entry, p1_raw_sl, p1_ref_vol, p1_int_fails] = find_bull_flag()
[p2_found, p2_raw_entry, p2_raw_sl, p2_ref_vol, p2_idx_a, p2_idx_b, p2_idx_c, p2_int_fails] = find_abcd()

bool cond_green_bar = close > open
bool cond_macd_ok = macd_line > 0 and (macd_hist > macd_hist[1] or macd_hist > 0)
bool cond_vwap_ok = close > vwap_val

float volume_check = volume
if barstate.isrealtime
    int time_elapsed = timenow - time
    int time_total = time_close - time
    if time_elapsed > 0 and time_total > 0
        volume_check := volume * (time_total / time_elapsed)

// This section finalizes Bull Flag trade parameters by applying secondary filters and profit-potential thresholds.
float p1_final_entry = p1_raw_entry
float p1_risk = p1_final_entry - p1_raw_sl
if p1_risk <= 0
    p1_risk := syminfo.mintick * 10
float p1_tp = p1_final_entry + (p1_risk * 2)

bool valid_p1 = p1_found

if valid_p1
    int p1_total_fails = p1_int_fails
    if p1_use_macd and not cond_macd_ok
        p1_total_fails += 1
    if p1_use_breakout_vol and volume_check <= p1_ref_vol
        p1_total_fails += 1
    if p1_use_vwap and p1_final_entry <= vwap_val
        valid_p1 := false
    if p1_total_fails > p1_allowed_fails
        valid_p1 := false
    if p1_use_green and not cond_green_bar
        valid_p1 := false
    
    if not show_low_profit and ((p1_tp - p1_final_entry) - commission_per_share) < 0.1
        valid_p1 := false

// This section calculates the final ABCD entry points and validates the setup against current market conditions and failure limits.
float p2_final_entry = p2_raw_entry
float p2_risk = p2_final_entry - p2_raw_sl
if p2_risk <= 0
    p2_risk := syminfo.mintick * 10
float p2_tp = p2_final_entry + (p2_risk * 2)

bool valid_p2 = p2_found

if valid_p2
    int p2_total_fails = p2_int_fails
    if p2_use_macd and not cond_macd_ok
        p2_total_fails += 1
    if p2_use_breakout_vol and volume_check <= p2_ref_vol
        p2_total_fails += 1
    if p2_use_vwap and p2_final_entry <= vwap_val
        valid_p2 := false
    if p2_total_fails > p2_allowed_fails
        valid_p2 := false
    if p2_use_green and not cond_green_bar
        valid_p2 := false
    
    if not show_low_profit and ((p2_tp - p2_final_entry) - commission_per_share) < 0.25
        valid_p2 := false

// This logic identifies a VWAP Break setup by ensuring price stays below VWAP for a duration before triggering on a cross.
bool valid_p3 = p3_enabled
bool under_vwap_series = close < vwap_val
float count_under = math.sum(under_vwap_series ? 1.0 : 0.0, p3_bars_required)
bool p3_setup_valid = count_under[1] == p3_bars_required
bool p3_is_near = (vwap_val - close) <= p3_gr_dist and close < vwap_val
bool p3_cross_trigger = p3_setup_valid and high >= vwap_val and (open < vwap_val or low < vwap_val)

if p3_enabled
    if p3_use_macd and not cond_macd_ok
        valid_p3 := false
    if not p3_cross_trigger
        valid_p3 := false

float p3_final_entry = vwap_val
float p3_final_sl = vwap_val - p3_sl_dist
float p3_final_tp = 0.0
float next_half = math.ceil(p3_final_entry * 2) / 2
if next_half <= p3_final_entry
    next_half := next_half + 0.5
float potential_hod = daily_high > p3_final_entry ? daily_high : 1000000.0
p3_final_tp := math.min(potential_hod, next_half)
if p3_final_tp <= p3_final_entry
    p3_final_tp := p3_final_entry + (p3_sl_dist * 2) 

// ====================================
// 8. GENERIC TRADE EXECUTION
// ====================================

// This loop manages the lifecycle of active trades by checking for price exits and updating visual indicators on the chart.
float total_commission_cost = commission_per_share * trade_qty

if active_trades.size() > 0
    for i = active_trades.size() - 1 to 0
        Trade t = active_trades.get(i)
        bool closed = false
        
        if low <= t.sl
            t.l_e.set_x2(bar_index)
            t.l_tp.set_x2(bar_index)
            t.l_sl.set_x2(bar_index)
            t.b_risk.set_right(bar_index)
            
            cnt_loss := cnt_loss + 1
            float gross_loss = (t.entry - t.sl) * trade_qty
            net_profit := net_profit - (gross_loss + total_commission_cost)
            
            last_exit_bar := bar_index
            status_txt := "Stop Loss Hit"
            t.lbl.set_text("Lose\n" + t.pat)
            t.lbl.set_color(color.red) 
            t.lbl.set_style(label.style_label_down)
            t.lbl.set_yloc(yloc.abovebar)
            closed := true
        else if high >= t.tp
            t.l_e.set_x2(bar_index)
            t.l_tp.set_x2(bar_index)
            t.l_sl.set_x2(bar_index)
            t.b_risk.set_right(bar_index)
            
            cnt_win := cnt_win + 1
            float gross_profit = (t.tp - t.entry) * trade_qty
            net_profit := net_profit + (gross_profit - total_commission_cost)
            
            last_exit_bar := bar_index
            status_txt := "Take Profit Hit"
            t.lbl.set_text("Win\n" + t.pat)
            t.lbl.set_color(color.green) 
            closed := true
        
        if closed
            active_trades.remove(i)
        else
            t.l_e.set_x2(bar_index + 5)
            t.l_tp.set_x2(bar_index + 5)
            t.l_sl.set_x2(bar_index + 5)
            t.b_risk.set_right(bar_index + 5)

// This block calculates logic for trade frequency limits and cooldown bar requirements.
int max_concurrent_trades = use_no_trade ? 1 : 999
bool cond_cooldown = (bar_index - last_exit_bar) > cooldown_bars

// ====================================
// EXECUTION: PATTERN 1
// ====================================
// This section triggers entries for the Bull Flag pattern and handles the generation of alerts and visual chart objects.
if time >= lookback_start_time
    bool p1_fresh_trigger = valid_p1 and high >= p1_final_entry
    bool p1_force_entry = p1_lock
    bool slots_available = active_trades.size() < max_concurrent_trades
    bool can_enter = slots_available and (not use_cooldown or cond_cooldown) and bar_index != last_entry_bar

    if can_enter and (p1_fresh_trigger or p1_force_entry)
        if not p1_lock
            p1_lock := true
            p1_lock_entry := p1_final_entry
            p1_lock_sl := p1_raw_sl
            p1_lock_tp := p1_tp
            alert("BUY SIGNAL | " + syminfo.ticker + " | Bull Flag", alert.freq_once_per_bar)

        float use_entry = p1_lock_entry
        float use_sl = p1_lock_sl
        float use_tp = p1_lock_tp
        last_entry_bar := bar_index

        color c_main = color.blue
        color c_tp = color.green
        color c_sl = color.red
        color c_box = color.teal

        line l_e_new = line.new(bar_index, use_entry, bar_index + 5, use_entry, color=c_main, width=2)
        line l_tp_new = line.new(bar_index, use_tp, bar_index + 5, use_tp, color=c_tp, width=2)
        line l_sl_new = line.new(bar_index, use_sl, bar_index + 5, use_sl, color=c_sl, width=2)
        box b_r_new = box.new(bar_index, use_tp, bar_index + 5, use_sl, bgcolor=color.new(c_box, 85), border_color=c_box)
        label lbl_new = label.new(bar_index, low, "BUY\nBull Flag", color=c_main, textcolor=color.white, style=label.style_label_up, yloc=yloc.belowbar, text_formatting=text.format_bold)

        array.push(weekly_lines, l_e_new)
        array.push(weekly_lines, l_tp_new)
        array.push(weekly_lines, l_sl_new)
        array.push(weekly_boxes, b_r_new)
        array.push(weekly_labels, lbl_new)

        Trade new_trade = Trade.new(use_entry, use_sl, use_tp, "Bull Flag", l_e_new, l_tp_new, l_sl_new, b_r_new, lbl_new, true)
        active_trades.push(new_trade)
        status_txt := "Bull Flag ENTRY"

    else if can_enter and not p1_fresh_trigger and not p1_force_entry and valid_p1
        label gr_lbl = label.new(bar_index, low, "GR\nBull Flag", color=color.orange, textcolor=color.white, style=label.style_label_up, yloc=yloc.belowbar, text_formatting=text.format_bold)
        array.push(weekly_labels, gr_lbl)
        alert("GET READY | " + syminfo.ticker + " | Bull Flag Found", alert.freq_once_per_bar)

// ====================================
// EXECUTION: PATTERN 2
// ====================================
// This section triggers entries for the ABCD pattern and places markers for the A, B, and C pivot points.
if time >= lookback_start_time
    bool p2_fresh_trigger = valid_p2 and high >= p2_final_entry
    bool p2_force_entry = p2_lock
    bool slots_available = active_trades.size() < max_concurrent_trades
    bool can_enter = slots_available and (not use_cooldown or cond_cooldown) and bar_index != last_entry_bar

    if can_enter and (p2_fresh_trigger or p2_force_entry)
        if not p2_lock
            p2_lock := true
            p2_lock_entry := p2_final_entry
            p2_lock_sl := p2_raw_sl
            p2_lock_tp := p2_tp
            alert("BUY SIGNAL | " + syminfo.ticker + " | ABCD", alert.freq_once_per_bar)

        float use_entry = p2_lock_entry
        float use_sl = p2_lock_sl
        float use_tp = p2_lock_tp
        last_entry_bar := bar_index

        color c_main = color.blue
        color c_tp = color.green
        color c_sl = color.red
        color c_box = color.teal

        line l_e_new = line.new(bar_index, use_entry, bar_index + 5, use_entry, color=c_main, width=2)
        line l_tp_new = line.new(bar_index, use_tp, bar_index + 5, use_tp, color=c_tp, width=2)
        line l_sl_new = line.new(bar_index, use_sl, bar_index + 5, use_sl, color=c_sl, width=2)
        box b_r_new = box.new(bar_index, use_tp, bar_index + 5, use_sl, bgcolor=color.new(c_box, 85), border_color=c_box)
        label lbl_new = label.new(bar_index, low, "BUY\nABCD", color=c_main, textcolor=color.white, style=label.style_label_up, yloc=yloc.belowbar, text_formatting=text.format_bold)

        array.push(weekly_lines, l_e_new)
        array.push(weekly_lines, l_tp_new)
        array.push(weekly_lines, l_sl_new)
        array.push(weekly_boxes, b_r_new)
        array.push(weekly_labels, lbl_new)

        label l_a = label.new(bar_index - p2_idx_a, low[p2_idx_a], "A", color=color.gray, textcolor=color.white, style=label.style_label_up, yloc=yloc.belowbar, size=size.small, text_formatting=text.format_bold)
        label l_b = label.new(bar_index - p2_idx_b, high[p2_idx_b], "B", color=color.gray, textcolor=color.white, style=label.style_label_down, yloc=yloc.abovebar, size=size.small, text_formatting=text.format_bold)
        label l_c = label.new(bar_index - p2_idx_c, low[p2_idx_c], "C", color=color.gray, textcolor=color.white, style=label.style_label_up, yloc=yloc.belowbar, size=size.small, text_formatting=text.format_bold)
        array.push(weekly_labels, l_a)
        array.push(weekly_labels, l_b)
        array.push(weekly_labels, l_c)

        Trade new_trade = Trade.new(use_entry, use_sl, use_tp, "ABCD", l_e_new, l_tp_new, l_sl_new, b_r_new, lbl_new, true)
        active_trades.push(new_trade)
        status_txt := "ABCD ENTRY"

    else if can_enter and not p2_fresh_trigger and not p2_force_entry and valid_p2
        label gr_lbl = label.new(bar_index, low, "GR\nABCD", color=color.orange, textcolor=color.white, style=label.style_label_up, yloc=yloc.belowbar, text_formatting=text.format_bold)
        array.push(weekly_labels, gr_lbl)
        alert("GET READY | " + syminfo.ticker + " | ABCD Found", alert.freq_once_per_bar)

// ====================================
// EXECUTION: PATTERN 3 (VWAP BREAK)
// ====================================
// This logic executes entries for the VWAP Break pattern and manages visual status updates during the entry process.
if time >= lookback_start_time
    bool p3_fresh_trigger = valid_p3
    bool p3_force_entry = p3_lock
    bool slots_available = active_trades.size() < max_concurrent_trades
    bool can_enter = slots_available and (not use_cooldown or cond_cooldown) and bar_index != last_entry_bar

    if can_enter and (p3_fresh_trigger or p3_force_entry)
        if not p3_lock
            p3_lock := true
            p3_lock_entry := p3_final_entry
            p3_lock_sl := p3_final_sl
            p3_lock_tp := p3_final_tp
            alert("BUY SIGNAL | " + syminfo.ticker + " | VWAP Break", alert.freq_once_per_bar)
        
        float use_entry = p3_lock_entry
        float use_sl = p3_lock_sl
        float use_tp = p3_lock_tp
        last_entry_bar := bar_index

        line l_e_new = line.new(bar_index, use_entry, bar_index + 5, use_entry, color=color.blue, width=2)
        line l_tp_new = line.new(bar_index, use_tp, bar_index + 5, use_tp, color=color.green, width=2)
        line l_sl_new = line.new(bar_index, use_sl, bar_index + 5, use_sl, color=color.red, width=2)
        box b_r_new = box.new(bar_index, use_tp, bar_index + 5, use_sl, bgcolor=color.new(color.teal, 85), border_color=color.teal)
        label lbl_new = label.new(bar_index, low, "BUY\nVWAP", color=color.blue, textcolor=color.white, style=label.style_label_up, yloc=yloc.belowbar, text_formatting=text.format_bold)

        array.push(weekly_lines, l_e_new)
        array.push(weekly_lines, l_tp_new)
        array.push(weekly_lines, l_sl_new)
        array.push(weekly_boxes, b_r_new)
        array.push(weekly_labels, lbl_new)

        Trade new_trade = Trade.new(use_entry, use_sl, use_tp, "VWAP Break", l_e_new, l_tp_new, l_sl_new, b_r_new, lbl_new, true)
        active_trades.push(new_trade)
        status_txt := "VWAP Break ENTRY"
    
    else if can_enter and not p3_fresh_trigger and not p3_force_entry and p3_is_near and p3_enabled
        bool filter_ok = not p3_use_macd or cond_macd_ok
        if filter_ok
            label gr_lbl = label.new(bar_index, low, "GR\nVWAP", color=color.orange, textcolor=color.white, style=label.style_label_up, yloc=yloc.belowbar, text_formatting=text.format_bold)
            array.push(weekly_labels, gr_lbl)

// ====================================
// 9. DASHBOARD
// ====================================

// This final block creates and updates an on-screen table to display current trade stats, performance metrics, and active trade values.
var table dashboard = table.new(position.top_right, 4, 4, color.new(color.black, 80), color.white, 1, color.white, 1)

if barstate.islast
    Trade last_t = active_trades.size() > 0 ? active_trades.get(active_trades.size() - 1) : Trade.new(na, na, na, "", line(na), line(na), line(na), box(na), label(na), false)
    string d_tp = na(last_t.tp) ? "0.00" : str.tostring(last_t.tp, format.mintick)
    string d_entry = na(last_t.entry) ? "0.00" : str.tostring(last_t.entry, format.mintick)
    string d_sl = na(last_t.sl) ? "0.00" : str.tostring(last_t.sl, format.mintick)
    table.cell(dashboard, 0, 0, "Perf (" + str.tostring(lookback_days) + "d | " + str.tostring(trade_qty) + "s)", text_color=color.white, text_size=size.normal, text_formatting=text.format_bold)
    table.cell(dashboard, 1, 0, "Trade Values", text_color=color.white, text_size=size.normal, text_formatting=text.format_bold)
    table.cell(dashboard, 3, 0, "Status", text_color=color.white, text_size=size.normal, text_formatting=text.format_bold)

    string wl_text = str.format("{0} W | {1} L", cnt_win, cnt_loss)
    table.cell(dashboard, 0, 1, wl_text, text_color=color.white)
    table.cell(dashboard, 1, 1, "TP:", text_color=color.green, text_halign=text.align_left)
    table.cell(dashboard, 2, 1, d_tp, text_color=color.white, text_halign=text.align_right)
    int active_cnt = active_trades.size()
    bool cooling_down = active_cnt == 0 and (bar_index - last_exit_bar) <= cooldown_bars
    string display_status = active_cnt > 0 ? "Active: " + str.tostring(active_cnt) : (cooling_down ? "Cooldown..." : status_txt)
    color stat_col = active_cnt > 0 ? color.orange : (status_txt == "Take Profit Hit" ? color.green : color.white)
    table.cell(dashboard, 3, 1, display_status, text_color=stat_col)
    color profit_bg = net_profit >= 0 ? color.new(color.green, 60) : color.new(color.red, 60)
    string profit_txt = str.tostring(math.round(net_profit)) + "$"
    table.cell(dashboard, 0, 2, profit_txt, bgcolor=profit_bg, text_color=color.white)
    
    float total_trades = cnt_win + cnt_loss
    float win_pct = total_trades > 0 ? (cnt_win / total_trades) * 100 : 0.0
    string win_pct_txt = "Win: " + str.tostring(win_pct, "0.0") + "%"
    table.cell(dashboard, 0, 3, win_pct_txt, text_color=color.white)

    table.cell(dashboard, 1, 2, "Entry:", text_color=color.blue, text_halign=text.align_left)
    table.cell(dashboard, 2, 2, d_entry, text_color=color.white, text_halign=text.align_right)

    table.cell(dashboard, 1, 3, "SL:", text_color=color.red, text_halign=text.align_left)
    table.cell(dashboard, 2, 3, d_sl, text_color=color.white, text_halign=text.align_right)

    table.merge_cells(dashboard, 1, 0, 2, 0)
    table.merge_cells(dashboard, 3, 1, 3, 3)
