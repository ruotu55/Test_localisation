//@version=6
indicator("Rom Master - Bull Flag", overlay=true)

// ====================================
// CONFIGURATION & GLOBAL VARIABLES
// ====================================

// --- MONEY MANAGEMENT SETTINGS ---
int trade_qty = input.int(250, "Trade Share Size", group="Money Management")
float commission_per_share = input.float(0.02, "Commission (Per Share - Round Trip)", group="Money Management", tooltip="Cost per share for a round-trip trade (buy + sell). Example: 0.02 means $50 commission for 2500 shares.")
int cooldown = input.int(2, "Cooldown Bars", group="Money Management")

// --- PERFORMANCE TRACKING SETTING ---
int lookback_days = input.int(7, "Performance Lookback (Days)", minval=1, group="Configuration", tooltip="Number of calendar days to track performance for. Set to 9999 to track all history.")

// --- PATTERN SETTINGS ---
int flag_min_bars = 1
int flag_max_bars = 5 

// --- FILTERS (TOGGLES) ---
bool use_breakout   = input.bool(true, "Wait for Candle Close?", group="Entry Filters", tooltip="ON = Wait for the candle to close above the entry line.\nOFF = Enter immediately when price touches the entry line.")
bool use_green_bar  = input.bool(true, "Entry Candle Must be Green?", group="Entry Filters", tooltip="ON = The candle that triggers the entry must be Green (Close > Open).")
bool use_no_trade   = input.bool(true, "Block Entry if Trade Active?", group="Entry Filters", tooltip="ON = Do not enter a new trade if you are currently in one.\nOFF = Allow multiple overlapping trades.")
bool use_cooldown   = input.bool(true, "Pause After Trade (Cooldown)?", group="Entry Filters", tooltip="ON = Wait for the 'Cooldown Bars' duration after a trade finishes before looking for new setups.")
bool use_depth_filter = input.bool(true, "Max Pullback Depth (30%)?", group="Entry Filters", tooltip="ON = The pullback must not exceed 30% of the FULL surge length.\nOFF = Ignore pullback depth (allow deeper pullbacks).")
bool use_vol_check    = input.bool(true, "Flag Volume < Pole Volume?", group="Entry Filters", tooltip="ON = Average volume of the flag (red) candles must be lower than the average volume of the pole (green) candles.")
bool use_breakout_vol = input.bool(true, "Breakout Vol > Flag Vol?", group="Entry Filters", tooltip="ON = The breakout candle volume must be higher than the average volume of the flag candles.")

// SMAs
float vol_ma_10 = ta.sma(volume, 10)

// Session Performance
var int cnt_win = 0
var int cnt_loss = 0
var float net_profit = 0.0

// Trade Values
var bool in_trade = false
var float tp_price = na
var float entry_price = na
var float sl_price = na

// COOLDOWN TRACKING
var int last_exit_bar = -999

// Status Text
var string status_txt = "Waiting"

// Visual Object References
var line l_entry = na
var line l_tp = na
var line l_sl = na
var box b_risk = na
var label active_trade_label = na // New variable to track the current trade's label

// Arrays for Weekly/Lookback Reset
var line[] weekly_lines = array.new_line()
var box[] weekly_boxes = array.new_box()
var label[] weekly_labels = array.new_label()

// ====================================
// LOOKBACK RESET LOGIC
// ====================================

// Calculate the timestamp for the start of the lookback period
int lookback_ms = lookback_days * 86400000 // Days to milliseconds (86400000 ms per day)
int lookback_start_time = time - lookback_ms

// Check if the current bar's time is the first bar *after* the lookback period starts
// This acts as the anchor point for the lookback reset
bool is_reset_bar = time[1] < lookback_start_time and time >= lookback_start_time and barstate.isfirst

if is_reset_bar
    // Reset counters
    cnt_win := 0
    cnt_loss := 0
    net_profit := 0.0
    status_txt := "Waiting"
    
    // CRITICAL FIX: Only delete visuals/prices if we are NOT in a trade.
    // This prevents the active trade lines/labels from disappearing.
    if not in_trade
        entry_price := na
        tp_price := na
        sl_price := na
        
        last_exit_bar := -999
        
        while array.size(weekly_lines) > 0
            line.delete(array.pop(weekly_lines))
        while array.size(weekly_boxes) > 0
            box.delete(array.pop(weekly_boxes))
        while array.size(weekly_labels) > 0
            label.delete(array.pop(weekly_labels))

// ====================================
// CORE: BULL FLAG PATTERN DETECTION
// ====================================

find_bull_flag_pattern() =>
    float ret_sl = na
    float ret_entry = na
    float ret_flag_vol = 0.0
    
    for f_len = flag_min_bars to flag_max_bars
        int pole_end_idx = f_len + 1
        
        bool is_pole = true
        for p = 0 to 2
            int idx = pole_end_idx + p
            if not (close[idx] > open[idx] and volume[idx] > vol_ma_10[idx])
                is_pole := false
        
        if is_pole
            float full_surge_high = high[pole_end_idx]
            float full_surge_low = low[pole_end_idx]
            float pole_vol_sum = 0.0
            int pole_bar_count = 0
            int scan_idx = pole_end_idx
            
            while close[scan_idx] > open[scan_idx]
                if high[scan_idx] > full_surge_high
                    full_surge_high := high[scan_idx]
                if low[scan_idx] < full_surge_low
                    full_surge_low := low[scan_idx]
                pole_vol_sum += volume[scan_idx]
                pole_bar_count += 1
                scan_idx := scan_idx + 1
                if scan_idx > pole_end_idx + 50 
                    break
            
            bool all_reds = true
            float lowest_flag_low = high 
            float flag_vol_sum = 0.0
            
            for k = 1 to f_len
                flag_vol_sum += volume[k]
                if close[k] >= open[k]
                    all_reds := false
                else
                    if low[k] < lowest_flag_low
                        lowest_flag_low := low[k]
            
            if all_reds
                float pole_height = full_surge_high - full_surge_low
                float pullback_depth = full_surge_high - lowest_flag_low
                float depth_ratio = pole_height > 0 ? (pullback_depth / pole_height) : 1.0
                float avg_pole_vol = pole_bar_count > 0 ? pole_vol_sum / pole_bar_count : 0.0
                float avg_flag_vol = f_len > 0 ? flag_vol_sum / f_len : 0.0
                bool vol_rule_passed = not use_vol_check or (avg_flag_vol < avg_pole_vol)
                
                if (not use_depth_filter or (depth_ratio <= 0.30)) and vol_rule_passed
                    ret_entry := high[1]
                    ret_sl := lowest_flag_low
                    ret_flag_vol := avg_flag_vol
                    break 

    [ret_sl, ret_entry, ret_flag_vol]

// ====================================
// TRADE EXECUTION
// ====================================

[sl_level, entry_level, flag_avg_vol] = find_bull_flag_pattern()

// Calculate total commission cost for the round trip
float total_commission_cost = commission_per_share * trade_qty

// --- 1. Exit Management (Updated for Label Change) ---
if in_trade
    if low <= sl_price
        cnt_loss := cnt_loss + 1
        float gross_loss = (entry_price - sl_price) * trade_qty
        net_profit := net_profit - (gross_loss + total_commission_cost)
        in_trade := false
        last_exit_bar := bar_index
        status_txt := "Stop Loss Hit"
        
        // Update Label to "Lose"
        if not na(active_trade_label)
            label.set_text(active_trade_label, "Lose")
            label.set_color(active_trade_label, color.red)
            label.set_style(active_trade_label, label.style_label_down)
            label.set_yloc(active_trade_label, yloc.abovebar)

    else if high >= tp_price
        cnt_win := cnt_win + 1
        float gross_profit = (tp_price - entry_price) * trade_qty
        net_profit := net_profit + (gross_profit - total_commission_cost)
        in_trade := false
        last_exit_bar := bar_index
        status_txt := "Take Profit Hit"
        
        // Update Label to "Win"
        if not na(active_trade_label)
            label.set_text(active_trade_label, "Win")
            label.set_color(active_trade_label, color.green)
            // Style remains label_up for win usually, or change as preferred

// --- 2. Entry Logic ---

bool pattern_found = not na(entry_level) 
bool cond_breakout = close > entry_level 
bool cond_green    = close > open        
bool cond_no_trade = not in_trade
bool cond_cooldown = (bar_index - last_exit_bar) > cooldown
bool cond_breakout_vol = volume > flag_avg_vol

bool trigger_buy = pattern_found and 
                   (not use_breakout or cond_breakout) and 
                   (not use_green_bar or cond_green) and 
                   (not use_no_trade or cond_no_trade) and 
                   (not use_cooldown or cond_cooldown) and
                   (not use_breakout_vol or cond_breakout_vol)

// Do not trigger a buy if the current bar is outside the lookback period
if time < lookback_start_time
    trigger_buy := false

if trigger_buy
    in_trade := true
    status_txt := "PIVOT ENTRY"
    
    entry_price := entry_level 
    sl_price := sl_level
    
    float risk = entry_price - sl_price
    if risk <= 0
        risk := syminfo.mintick * 10

    tp_price := entry_price + (risk * 2)

// ====================================
// Chart Visuals
// ====================================

if trigger_buy
    l_entry := line.new(x1=bar_index, y1=entry_price, x2=bar_index, y2=entry_price, color=color.blue, width=2, style=line.style_solid)
    l_tp := line.new(x1=bar_index, y1=tp_price, x2=bar_index, y2=tp_price, color=color.green, width=2)
    l_sl := line.new(x1=bar_index, y1=sl_price, x2=bar_index, y2=sl_price, color=color.red, width=2)
    b_risk := box.new(left=bar_index, top=tp_price, right=bar_index, bottom=sl_price, bgcolor=color.new(color.teal, 85), border_color=color.teal)

    // Store the specific label for this trade in 'active_trade_label'
    active_trade_label := label.new(
         x=bar_index, 
         y=low, 
         text="BUY", 
         color=color.blue, 
         textcolor=color.white, 
         style=label.style_label_up, 
         yloc=yloc.belowbar
         )

    array.push(weekly_lines, l_entry)
    array.push(weekly_lines, l_tp)
    array.push(weekly_lines, l_sl)
    array.push(weekly_boxes, b_risk)
    array.push(weekly_labels, active_trade_label)

if in_trade or (bar_index == last_exit_bar)
    line.set_x2(l_entry, bar_index)
    line.set_x2(l_tp, bar_index)
    line.set_x2(l_sl, bar_index)
    box.set_right(b_risk, bar_index)

// ====================================
// Table Summary
// ====================================

var table dashboard = table.new(position.top_right, 4, 4, color.new(color.black, 80), color.white, 1, color.white, 1)

if barstate.islast
    string d_tp = na(tp_price) ? "0.00" : str.tostring(tp_price, format.mintick)
    string d_entry = na(entry_price) ? "0.00" : str.tostring(entry_price, format.mintick)
    string d_sl = na(sl_price) ? "0.00" : str.tostring(sl_price, format.mintick)

    table.cell(dashboard, 0, 0, "Perf (" + str.tostring(lookback_days) + "d | " + str.tostring(trade_qty) + "s)", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 0, "Trade Values", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 3, 0, "Status", text_color=color.white, text_size=size.small)

    string wl_text = str.format("{0} W | {1} L", cnt_win, cnt_loss)
    table.cell(dashboard, 0, 1, wl_text, text_color=color.white)
    table.cell(dashboard, 1, 1, "TP:", text_color=color.green, text_halign=text.align_left)
    table.cell(dashboard, 2, 1, d_tp, text_color=color.white, text_halign=text.align_right)

    color stat_col = in_trade ? color.yellow : (status_txt == "Take Profit Hit" ? color.green : color.white)
    bool cooling_down = not in_trade and (bar_index - last_exit_bar) <= cooldown
    string display_status = cooling_down ? "Cooldown..." : status_txt
    table.cell(dashboard, 3, 1, display_status, text_color=stat_col)

    color profit_bg = net_profit >= 0 ? color.new(color.green, 60) : color.new(color.red, 60)
    string profit_txt = str.tostring(net_profit, format.mintick) + "$"
    table.cell(dashboard, 0, 2, profit_txt, bgcolor=profit_bg, text_color=color.white)

    table.cell(dashboard, 1, 2, "Entry:", text_color=color.blue, text_halign=text.align_left)
    table.cell(dashboard, 2, 2, d_entry, text_color=color.white, text_halign=text.align_right)

    table.cell(dashboard, 1, 3, "SL:", text_color=color.red, text_halign=text.align_left)
    table.cell(dashboard, 2, 3, d_sl, text_color=color.white, text_halign=text.align_right)

    table.merge_cells(dashboard, 1, 0, 2, 0)
    table.merge_cells(dashboard, 0, 2, 0, 3)
    table.merge_cells(dashboard, 3, 1, 3, 3)
