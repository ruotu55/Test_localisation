//@version=6
indicator("Rom Master - Multi-Pattern Strategy", overlay=true)

// ====================================
// 1. GLOBAL CONFIGURATION & GENERICS
// ====================================

// --- MONEY MANAGEMENT & PERFORMANCE ---
int trade_qty = input.int(250, "Trade Share Size", group="═════ MONEY MANAGEMENT ═════")
float commission_per_share = input.float(0.02, "Commission (Per Share - Round Trip)", group="═════ MONEY MANAGEMENT ═════", tooltip="Cost per share for a round-trip trade (buy + sell). Example: 0.02 means $50 commission for 2500 shares.")
int lookback_days = input.int(7, "Performance History (Days)", minval=1, group="═════ MONEY MANAGEMENT ═════", tooltip="Number of calendar days to track performance for. Set to 9999 to track all history.")

// --- GENERIC ENTRY FILTERS (Apply to ALL Patterns) ---
bool use_no_trade = input.bool(true, "Block Entry if Trade Active?", group="═════ GLOBAL ENTRY FILTERS ═════", tooltip="ON = Strictly 1 trade at a time.\nOFF = Allows up to 2 trades at the same time.")
bool use_cooldown = input.bool(true, "Pause After Trade (Cooldown)?", group="═════ GLOBAL ENTRY FILTERS ═════", tooltip="ON = Wait for the 'Cooldown Bars' duration after a trade finishes before looking for new setups.")
bool use_psych_filter = input.bool(true, "Clear Psych Levels ($X.00/.50)?", group="═════ GLOBAL ENTRY FILTERS ═════", tooltip="ON = If the pattern entry is slightly below a Whole ($X.00) or Half ($X.50) dollar level, move the entry price slightly ABOVE it to clear resistance.")
bool use_macd_filter = input.bool(true, "MACD > 0 & > Signal?", group="═════ GLOBAL ENTRY FILTERS ═════", tooltip="ON = Entry allowed only if MACD is positive (>0) and the MACD line is above the Signal line.")
bool use_vwap_filter = input.bool(true, "Price > VWAP?", group="═════ GLOBAL ENTRY FILTERS ═════", tooltip="ON = Entry allowed only if the price (Close) is above the Volume Weighted Average Price.")
bool use_hod_filter = input.bool(true, "TP <= Day High?", group="═════ GLOBAL ENTRY FILTERS ═════", tooltip="ON = Do not create a buy signal if the calculated Take Profit is above the current High of the Day.")

// --- GLOBAL VARIABLES & INDICATORS ---
int cooldown = 2
float vol_ma_10 = ta.sma(volume, 10)
float vwap_val = ta.vwap(close)
[macd_line, signal_line, _] = ta.macd(close, 12, 26, 9)
float daily_high = request.security(syminfo.tickerid, "D", high)

// --- CUSTOM TYPE FOR MULTI-TRADE SUPPORT ---
type Trade
    float entry
    float sl
    float tp
    string pat
    line l_e
    line l_tp
    line l_sl
    box b_risk
    label lbl

// Trade State Variables
var Trade[] active_trades = array.new<Trade>() // Array to hold multiple trades
var int cnt_win = 0
var int cnt_loss = 0
var float net_profit = 0.0
var int last_exit_bar = -999
var string status_txt = "Waiting"

// Visual Arrays for Clean Up
var line[] weekly_lines = array.new_line()
var box[] weekly_boxes = array.new_box()
var label[] weekly_labels = array.new_label()

// ====================================
// 2. PATTERN 1: BULL FLAG SETTINGS
// ====================================
// Specific inputs for the Bull Flag pattern only
int p1_pole_min_bars = 2
int p1_flag_min_bars = 1
int p1_flag_max_bars = 5
bool p1_use_depth = input.bool(true, "Max Pullback Depth (50%)?", group="═════ PATTERN 1: BULL FLAG ═════", tooltip="ON = The pullback must not exceed 50% of the FULL surge length (Text recommends top 25%).\nOFF = Ignore pullback depth.")
bool p1_use_vol = input.bool(true, "Flag Vol < Pole Vol?", group="═════ PATTERN 1: BULL FLAG ═════", tooltip="ON = Average volume of the flag (red) candles must be lower than the average volume of the pole (green) candles.")
bool p1_use_breakout_vol = input.bool(true, "Breakout Vol > Flag Vol?", group="═════ PATTERN 1: BULL FLAG ═════", tooltip="ON = The breakout candle volume must be higher than the average volume of the flag candles.")
bool use_green_bar = input.bool(true, "Entry Candle Must be Green?", group="═════ PATTERN 1: BULL FLAG ═════", tooltip="ON = The candle that triggers the entry must be Green (Close > Open).")

// --- NEW WICK FILTERS ---
bool p1_avoid_wick = input.bool(true, "Avoid Pole Top Wick?", group="═════ PATTERN 1: BULL FLAG ═════", tooltip="ON = Cancel pattern if the last candle of the surge (the top) has a long upper wick.")
float p1_wick_ratio = input.float(0.33, "Pole Top Wick/Body Ratio", group="═════ PATTERN 1: BULL FLAG ═════", tooltip="If 'Avoid Pole Top Wick' is ON: The pattern is invalid if Upper Wick > (Body * Ratio). Example: 0.33 means wick larger than 1/3rd of body is rejected.")

// ====================================
// 3. LOGIC: RESET MECHANISM
// ====================================
int lookback_ms = lookback_days * 86400000
int lookback_start_time = timenow - lookback_ms
bool is_reset_bar = time[1] < lookback_start_time and time >= lookback_start_time

if is_reset_bar
    cnt_win := 0
    cnt_loss := 0
    net_profit := 0.0
    status_txt := "Waiting"
    last_exit_bar := -999
    // Clear active trades on reset
    active_trades.clear()
    
    while array.size(weekly_lines) > 0
        line.delete(array.pop(weekly_lines))
    while array.size(weekly_boxes) > 0
        box.delete(array.pop(weekly_boxes))
    while array.size(weekly_labels) > 0
        label.delete(array.pop(weekly_labels))

// ====================================
// 4. PATTERN RECOGNITION FUNCTIONS
// ====================================

find_bull_flag() =>
    float ret_sl = na
    float ret_entry = na
    float ret_flag_vol = 0.0
    bool ret_found = false

    for f_len = p1_flag_min_bars to p1_flag_max_bars
        int pole_end_idx = f_len + 1
        bool is_pole = true
        
        int high_vol_count = 0
        for p = 0 to p1_pole_min_bars - 1
            int idx = pole_end_idx + p
            if close[idx] <= open[idx]
                is_pole := false
                break
            if volume[idx] > vol_ma_10[idx]
                high_vol_count += 1
        
        if is_pole
            int vol_threshold = math.floor(p1_pole_min_bars / 2)
            if high_vol_count < vol_threshold
                is_pole := false

        if is_pole and p1_avoid_wick
            float top_high = high[pole_end_idx]
            float top_open = open[pole_end_idx]
            float top_close = close[pole_end_idx]
            float u_wick = top_high - math.max(top_open, top_close)
            float body = math.abs(top_close - top_open)
            if u_wick > (body * p1_wick_ratio)
                is_pole := false

        if is_pole
            float full_surge_high = high[pole_end_idx]
            float full_surge_low = low[pole_end_idx]
            float pole_vol_sum = 0.0
            int pole_bar_count = 0
            int scan_idx = pole_end_idx
            
            while close[scan_idx] > open[scan_idx]
                if high[scan_idx] > full_surge_high
                    full_surge_high := high[scan_idx]
                if low[scan_idx] < full_surge_low
                    full_surge_low := low[scan_idx]
                pole_vol_sum += volume[scan_idx]
                pole_bar_count += 1
                scan_idx := scan_idx + 1
                if scan_idx > pole_end_idx + 50
                    break
            
            bool is_valid_flag = true
            float lowest_flag_low = high
            float flag_vol_sum = 0.0
            float potential_entry = na
            float potential_sl = na
            
            bool has_green_tip = close[1] > open[1]
            
            if has_green_tip
                if f_len < 2 or high[1] >= high[2]
                    is_valid_flag := false
                else
                    flag_vol_sum := volume[1]
                    lowest_flag_low := math.min(lowest_flag_low, low[1])
                    potential_entry := high[1]
                    potential_sl := low[1]
                    for k = 2 to f_len
                        if close[k] >= open[k]
                            is_valid_flag := false
                            break
                        else
                            lowest_flag_low := math.min(lowest_flag_low, low[k])
            else
                potential_entry := high[1]
                potential_sl := low[1]
                flag_vol_sum := volume[1]
                for k = 1 to f_len
                    if close[k] >= open[k]
                        is_valid_flag := false
                        break
                    else
                        lowest_flag_low := math.min(lowest_flag_low, low[k])
            
            if is_valid_flag
                float pole_height = full_surge_high - full_surge_low
                float pullback_depth = full_surge_high - lowest_flag_low
                float depth_ratio = pole_height > 0 ? (pullback_depth / pole_height) : 1.0
                float avg_pole_vol = pole_bar_count > 0 ? pole_vol_sum / pole_bar_count : 0.0
                float avg_flag_vol = flag_vol_sum 
                
                bool vol_rule_passed = not p1_use_vol or (avg_flag_vol < avg_pole_vol)
                bool depth_rule_passed = not p1_use_depth or (depth_ratio <= 0.50)

                if depth_rule_passed and vol_rule_passed
                    ret_entry := potential_entry
                    ret_sl := potential_sl
                    ret_flag_vol := avg_flag_vol
                    ret_found := true
                    break 

    [ret_found, ret_entry, ret_sl, ret_flag_vol]

// ====================================
// 5. SIGNAL AGGREGATION
// ====================================

[p1_found, p1_entry, p1_sl, p1_ref_vol] = find_bull_flag()

bool p2_found = false
float p2_entry = na
float p2_sl = na
float p2_ref_vol = 0.0

bool pattern_detected = false
float raw_entry = na
float raw_sl = na
float raw_ref_vol = na
string pattern_name = ""

if p1_found
    pattern_detected := true
    raw_entry := p1_entry
    raw_sl := p1_sl
    raw_ref_vol := p1_ref_vol
    pattern_name := "Bull Flag"
else if p2_found
    pattern_detected := true
    raw_entry := p2_entry
    raw_sl := p2_sl
    raw_ref_vol := p2_ref_vol
    pattern_name := "Pattern 2"

// ====================================
// 6. GENERIC TRADE EXECUTION (MULTI-TRADE)
// ====================================

float final_entry = raw_entry
if use_psych_filter and not na(raw_entry)
    float next_whole = math.ceil(raw_entry)
    float next_half = math.ceil(raw_entry * 2.0) / 2.0
    float nearest_res = math.min(next_whole, next_half)
    float dist = nearest_res - raw_entry
    if dist > 0 and dist < (raw_entry * 0.005)
        final_entry := nearest_res + syminfo.mintick

float total_commission_cost = commission_per_share * trade_qty

// --- MANAGE ACTIVE TRADES (EXIT LOGIC) ---
// Loop backwards to safely remove closed trades from the array
if active_trades.size() > 0
    for i = active_trades.size() - 1 to 0
        Trade t = active_trades.get(i)
        bool closed = false
        
        // Update Visuals (Drag lines forward)
        t.l_e.set_x2(bar_index)
        t.l_tp.set_x2(bar_index)
        t.l_sl.set_x2(bar_index)
        t.b_risk.set_right(bar_index)

        // Check SL
        if low <= t.sl
            cnt_loss := cnt_loss + 1
            float gross_loss = (t.entry - t.sl) * trade_qty
            net_profit := net_profit - (gross_loss + total_commission_cost)
            last_exit_bar := bar_index
            status_txt := "Stop Loss Hit"
            
            t.lbl.set_text("Lose\n" + t.pat)
            t.lbl.set_color(color.red)
            t.lbl.set_style(label.style_label_down)
            t.lbl.set_yloc(yloc.abovebar)
            closed := true

        // Check TP
        else if high >= t.tp
            cnt_win := cnt_win + 1
            float gross_profit = (t.tp - t.entry) * trade_qty
            net_profit := net_profit + (gross_profit - total_commission_cost)
            last_exit_bar := bar_index
            status_txt := "Take Profit Hit"
            
            t.lbl.set_text("Win\n" + t.pat)
            t.lbl.set_color(color.green)
            closed := true
            
        if closed
            active_trades.remove(i)

// --- ENTRY FILTERS ---
bool cond_breakout = high >= final_entry

float volume_check = volume
if barstate.isrealtime
    int time_elapsed = timenow - time
    int time_total = time_close - time
    if time_elapsed > 0 and time_total > 0
        volume_check := volume * (time_total / time_elapsed)

bool cond_green = close > open
bool cond_cooldown = (bar_index - last_exit_bar) > cooldown
bool cond_macd = macd_line > 0 and macd_line > signal_line
bool cond_vwap = close > vwap_val

bool cond_p1_vol = true 
if p1_found and p1_use_breakout_vol
    cond_p1_vol := volume_check > raw_ref_vol

float calc_risk = final_entry - raw_sl
if calc_risk <= 0
    calc_risk := syminfo.mintick * 10
float projected_tp = final_entry + (calc_risk * 2)
bool cond_tp_valid = projected_tp <= daily_high

// --- TRADE SLOT MANAGEMENT ---
// If use_no_trade is ON (true), Max 1 trade.
// If use_no_trade is OFF (false), Max 2 trades.
int max_concurrent_trades = use_no_trade ? 1 : 2
bool slots_available = active_trades.size() < max_concurrent_trades

// --- MASTER BUY TRIGGER ---
bool trigger_buy = pattern_detected and 
     cond_breakout and 
     slots_available and // Check if we have space for a new trade
     (not use_green_bar or cond_green) and 
     (not use_cooldown or cond_cooldown) and 
     (not use_macd_filter or cond_macd) and
     (not use_vwap_filter or cond_vwap) and
     (not use_hod_filter or cond_tp_valid) and
     cond_p1_vol

if time < lookback_start_time
    trigger_buy := false

// --- MASTER GR TRIGGER ---
bool trigger_gr = pattern_detected and
     not cond_breakout and 
     slots_available and 
     (not use_cooldown or cond_cooldown) and 
     (not use_macd_filter or cond_macd) and
     (not use_vwap_filter or cond_vwap) and
     (not use_hod_filter or cond_tp_valid) and
     cond_p1_vol

if time < lookback_start_time
    trigger_gr := false

if trigger_gr
    label gr_lbl = label.new(bar_index, low, "GR", color=color.orange, textcolor=color.white, style=label.style_label_up, yloc=yloc.belowbar, text_formatting=text.format_bold)
    array.push(weekly_labels, gr_lbl)

if trigger_buy
    float entry_p = final_entry
    float sl_p = raw_sl
    float risk = entry_p - sl_p
    if risk <= 0
        risk := syminfo.mintick * 10
    float tp_p = entry_p + (risk * 2)
    
    // Create Visuals
    line l_e_new = line.new(bar_index, entry_p, bar_index, entry_p, color=color.blue, width=2)
    line l_tp_new = line.new(bar_index, tp_p, bar_index, tp_p, color=color.green, width=2)
    line l_sl_new = line.new(bar_index, sl_p, bar_index, sl_p, color=color.red, width=2)
    box b_r_new = box.new(bar_index, tp_p, bar_index, sl_p, bgcolor=color.new(color.teal, 85), border_color=color.teal)
    label lbl_new = label.new(bar_index, low, "BUY\n" + pattern_name, color=color.blue, textcolor=color.white, style=label.style_label_up, yloc=yloc.belowbar, text_formatting=text.format_bold)

    // Store in clean-up arrays
    array.push(weekly_lines, l_e_new)
    array.push(weekly_lines, l_tp_new)
    array.push(weekly_lines, l_sl_new)
    array.push(weekly_boxes, b_r_new)
    array.push(weekly_labels, lbl_new)

    // Create Trade Object and Add to Active List
    Trade new_trade = Trade.new(entry_p, sl_p, tp_p, pattern_name, l_e_new, l_tp_new, l_sl_new, b_r_new, lbl_new)
    active_trades.push(new_trade)
    
    status_txt := pattern_name + " ENTRY"

// ====================================
// 7. DASHBOARD
// ====================================

var table dashboard = table.new(position.top_right, 4, 4, color.new(color.black, 80), color.white, 1, color.white, 1)

if barstate.islast
    // Get stats from the MOST RECENT trade if exists, otherwise 0
    Trade last_t = active_trades.size() > 0 ? active_trades.get(active_trades.size() - 1) : na
    
    string d_tp = na(last_t) ? "0.00" : str.tostring(last_t.tp, format.mintick)
    string d_entry = na(last_t) ? "0.00" : str.tostring(last_t.entry, format.mintick)
    string d_sl = na(last_t) ? "0.00" : str.tostring(last_t.sl, format.mintick)
    
    table.cell(dashboard, 0, 0, "Perf (" + str.tostring(lookback_days) + "d | " + str.tostring(trade_qty) + "s)", text_color=color.white, text_size=size.normal, text_formatting=text.format_bold)
    table.cell(dashboard, 1, 0, "Trade Values", text_color=color.white, text_size=size.normal, text_formatting=text.format_bold)
    table.cell(dashboard, 3, 0, "Status", text_color=color.white, text_size=size.normal, text_formatting=text.format_bold)

    string wl_text = str.format("{0} W | {1} L", cnt_win, cnt_loss)
    table.cell(dashboard, 0, 1, wl_text, text_color=color.white)
    table.cell(dashboard, 1, 1, "TP:", text_color=color.green, text_halign=text.align_left)
    table.cell(dashboard, 2, 1, d_tp, text_color=color.white, text_halign=text.align_right)
    
    int active_cnt = active_trades.size()
    bool cooling_down = active_cnt == 0 and (bar_index - last_exit_bar) <= cooldown
    string display_status = active_cnt > 0 ? "Active: " + str.tostring(active_cnt) : (cooling_down ? "Cooldown..." : status_txt)
    color stat_col = active_cnt > 0 ? color.yellow : (status_txt == "Take Profit Hit" ? color.green : color.white)
    
    table.cell(dashboard, 3, 1, display_status, text_color=stat_col)
    
    color profit_bg = net_profit >= 0 ? color.new(color.green, 60) : color.new(color.red, 60)
    string profit_txt = str.tostring(net_profit, format.mintick) + "$"
    table.cell(dashboard, 0, 2, profit_txt, bgcolor=profit_bg, text_color=color.white)
    
    table.cell(dashboard, 1, 2, "Entry:", text_color=color.blue, text_halign=text.align_left)
    table.cell(dashboard, 2, 2, d_entry, text_color=color.white, text_halign=text.align_right)

    table.cell(dashboard, 1, 3, "SL:", text_color=color.red, text_halign=text.align_left)
    table.cell(dashboard, 2, 3, d_sl, text_color=color.white, text_halign=text.align_right)

    table.merge_cells(dashboard, 1, 0, 2, 0)
    table.merge_cells(dashboard, 0, 2, 0, 3)
    table.merge_cells(dashboard, 3, 1, 3, 3)

// ====================================
// 8. ALERT CONFIGURATION
// ====================================

if trigger_buy
    alert("BUY SIGNAL | " + syminfo.ticker + " | Entry: " + str.tostring(final_entry) + " | SL: " + str.tostring(raw_sl), alert.freq_once_per_bar_close)
else if trigger_gr
    alert("GET READY | " + syminfo.ticker + " | Pattern Detected. Watch for breakout.", alert.freq_once_per_bar_close)

alertcondition(trigger_buy, title="Alert: BUY Signal", message="BUY {{ticker}} | Price: {{close}} | Check Chart")
alertcondition(trigger_gr, title="Alert: GET READY", message="GET READY {{ticker}} | Pattern Found")
