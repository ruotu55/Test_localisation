//@version=6
indicator("Rom Master - Multi-Pattern Strategy", overlay=true)

// ====================================
// 1. GLOBAL CONFIGURATION & GENERICS
// ====================================

// --- MONEY MANAGEMENT & PERFORMANCE ---
int trade_qty = input.int(250, "Trade Share Size", group="═════ MONEY MANAGEMENT ═════")
float commission_per_share = input.float(0.02, "Commission (Per Share - Round Trip)", group="═════ MONEY MANAGEMENT ═════", tooltip="Cost per share for a round-trip trade (buy + sell). Example: 0.02 means $50 commission for 2500 shares.")
int lookback_days = input.int(7, "Performance History (Days)", minval=1, group="═════ MONEY MANAGEMENT ═════", tooltip="Number of calendar days to track performance for. Set to 9999 to track all history.")

// --- GENERIC ENTRY FILTERS (Apply to ALL Patterns) ---
bool use_no_trade = input.bool(true, "Block Entry if Trade Active?", group="═════ GLOBAL ENTRY FILTERS ═════", tooltip="ON = Do not enter a new trade if you are currently in one.\nOFF = Allow multiple overlapping trades.")
bool use_cooldown = input.bool(true, "Pause After Trade (Cooldown)?", group="═════ GLOBAL ENTRY FILTERS ═════", tooltip="ON = Wait for the 'Cooldown Bars' duration after a trade finishes before looking for new setups.")
bool use_psych_filter = input.bool(true, "Clear Psych Levels ($X.00/.50)?", group="═════ GLOBAL ENTRY FILTERS ═════", tooltip="ON = If the pattern entry is slightly below a Whole ($X.00) or Half ($X.50) dollar level, move the entry price slightly ABOVE it to clear resistance.")
bool use_macd_filter = input.bool(true, "MACD > 0 & > Signal?", group="═════ GLOBAL ENTRY FILTERS ═════", tooltip="ON = Entry allowed only if MACD is positive (>0) and the MACD line is above the Signal line.")
bool use_vwap_filter = input.bool(true, "Price > VWAP?", group="═════ GLOBAL ENTRY FILTERS ═════", tooltip="ON = Entry allowed only if the price (Close) is above the Volume Weighted Average Price.")
bool use_hod_filter = input.bool(true, "TP <= Day High?", group="═════ GLOBAL ENTRY FILTERS ═════", tooltip="ON = Do not create a buy signal if the calculated Take Profit is above the current High of the Day.")

// --- GLOBAL VARIABLES & INDICATORS ---
int cooldown = 2
float vol_ma_10 = ta.sma(volume, 10)
float vwap_val = ta.vwap(close)
[macd_line, signal_line, _] = ta.macd(close, 12, 26, 9)
float daily_high = request.security(syminfo.tickerid, "D", high)

// Trade State Variables
var int cnt_win = 0
var int cnt_loss = 0
var float net_profit = 0.0
var bool in_trade = false
var float tp_price = na
var float entry_price = na
var float sl_price = na
var int last_exit_bar = -999
var string status_txt = "Waiting"
var string trade_pattern = "" 

// Visual Objects
var line l_entry = na
var line l_tp = na
var line l_sl = na
var box b_risk = na
var label active_trade_label = na

// Reset Arrays
var line[] weekly_lines = array.new_line()
var box[] weekly_boxes = array.new_box()
var label[] weekly_labels = array.new_label()

// ====================================
// 2. PATTERN 1: BULL FLAG SETTINGS
// ====================================
// Specific inputs for the Bull Flag pattern only
int p1_pole_min_bars = 2
int p1_flag_min_bars = 1
int p1_flag_max_bars = 5
bool p1_use_depth = input.bool(true, "Max Pullback Depth (30%)?", group="═════ PATTERN 1: BULL FLAG ═════", tooltip="ON = The pullback must not exceed 30% of the FULL surge length (Text recommends top 25%).\nOFF = Ignore pullback depth.")
bool p1_use_vol = input.bool(true, "Flag Vol < Pole Vol?", group="═════ PATTERN 1: BULL FLAG ═════", tooltip="ON = Average volume of the flag (red) candles must be lower than the average volume of the pole (green) candles.")
bool p1_use_breakout_vol = input.bool(true, "Breakout Vol > Flag Vol?", group="═════ PATTERN 1: BULL FLAG ═════", tooltip="ON = The breakout candle volume must be higher than the average volume of the flag candles.")
bool use_green_bar = input.bool(true, "Entry Candle Must be Green?", group="═════ PATTERN 1: BULL FLAG ═════", tooltip="ON = The candle that triggers the entry must be Green (Close > Open).")

// ====================================
// 3. LOGIC: RESET MECHANISM
// ====================================
int lookback_ms = lookback_days * 86400000
int lookback_start_time = timenow - lookback_ms
bool is_reset_bar = time[1] < lookback_start_time and time >= lookback_start_time

if is_reset_bar
    cnt_win := 0
    cnt_loss := 0
    net_profit := 0.0
    status_txt := "Waiting"
    trade_pattern := ""
    if not in_trade
        entry_price := na
        tp_price := na
        sl_price := na
        last_exit_bar := -999
    while array.size(weekly_lines) > 0
        line.delete(array.pop(weekly_lines))
    while array.size(weekly_boxes) > 0
        box.delete(array.pop(weekly_boxes))
    while array.size(weekly_labels) > 0
        label.delete(array.pop(weekly_labels))

// ====================================
// 4. PATTERN RECOGNITION FUNCTIONS
// ====================================

// --- Function: Bull Flag Detection ---
find_bull_flag() =>
    float ret_sl = na
    float ret_entry = na
    float ret_flag_vol = 0.0
    bool ret_found = false

    for f_len = p1_flag_min_bars to p1_flag_max_bars
        int pole_end_idx = f_len + 1
        bool is_pole = true
        
        // Pole High Volume Check
        int high_vol_count = 0
        for p = 0 to p1_pole_min_bars - 1
            int idx = pole_end_idx + p
            if close[idx] <= open[idx]
                is_pole := false
                break
            if volume[idx] > vol_ma_10[idx]
                high_vol_count += 1
        
        if is_pole
            int vol_threshold = math.floor(p1_pole_min_bars / 2)
            if high_vol_count < vol_threshold
                is_pole := false

        if is_pole
            float full_surge_high = high[pole_end_idx]
            float full_surge_low = low[pole_end_idx]
            float pole_vol_sum = 0.0
            int pole_bar_count = 0
            int scan_idx = pole_end_idx
            
            // Find extent of the pole
            while close[scan_idx] > open[scan_idx]
                if high[scan_idx] > full_surge_high
                    full_surge_high := high[scan_idx]
                if low[scan_idx] < full_surge_low
                    full_surge_low := low[scan_idx]
                pole_vol_sum += volume[scan_idx]
                pole_bar_count += 1
                scan_idx := scan_idx + 1
                if scan_idx > pole_end_idx + 50
                    break
            
            // Flag Logic
            bool is_valid_flag = true
            float lowest_flag_low = high
            float flag_vol_sum = 0.0
            float potential_entry = na
            float potential_sl = na
            
            bool has_green_tip = close[1] > open[1]
            
            if has_green_tip
                if f_len < 2 or high[1] >= high[2]
                    is_valid_flag := false
                else
                    flag_vol_sum := volume[1]
                    lowest_flag_low := math.min(lowest_flag_low, low[1])
                    potential_entry := high[1]
                    potential_sl := low[1]
                    for k = 2 to f_len
                        if close[k] >= open[k]
                            is_valid_flag := false
                            break
                        else
                            lowest_flag_low := math.min(lowest_flag_low, low[k])
            else
                potential_entry := high[1]
                potential_sl := low[1]
                flag_vol_sum := volume[1]
                for k = 1 to f_len
                    if close[k] >= open[k]
                        is_valid_flag := false
                        break
                    else
                        lowest_flag_low := math.min(lowest_flag_low, low[k])
            
            if is_valid_flag
                float pole_height = full_surge_high - full_surge_low
                float pullback_depth = full_surge_high - lowest_flag_low
                float depth_ratio = pole_height > 0 ? (pullback_depth / pole_height) : 1.0
                float avg_pole_vol = pole_bar_count > 0 ? pole_vol_sum / pole_bar_count : 0.0
                float avg_flag_vol = flag_vol_sum // Current logic uses last bar vol as avg
                
                // Specific Flag Filters
                bool vol_rule_passed = not p1_use_vol or (avg_flag_vol < avg_pole_vol)
                bool depth_rule_passed = not p1_use_depth or (depth_ratio <= 0.30)

                if depth_rule_passed and vol_rule_passed
                    ret_entry := potential_entry
                    ret_sl := potential_sl
                    ret_flag_vol := avg_flag_vol
                    ret_found := true
                    break // Found valid flag, stop searching

    [ret_found, ret_entry, ret_sl, ret_flag_vol]

// ====================================
// 5. SIGNAL AGGREGATION (THE BRAIN)
// ====================================

// A. Check Pattern 1 (Bull Flag)
[p1_found, p1_entry, p1_sl, p1_ref_vol] = find_bull_flag()

// B. Check Pattern 2 (Example / Placeholder)
bool p2_found = false
float p2_entry = na
float p2_sl = na
float p2_ref_vol = 0.0

// C. Determine Final Signal
// We prioritize patterns. If P1 found, use P1. If not, check P2.
bool pattern_detected = false
float raw_entry = na
float raw_sl = na
float raw_ref_vol = na
string pattern_name = ""

if p1_found
    pattern_detected := true
    raw_entry := p1_entry
    raw_sl := p1_sl
    raw_ref_vol := p1_ref_vol
    pattern_name := "Bull Flag"
else if p2_found
    pattern_detected := true
    raw_entry := p2_entry
    raw_sl := p2_sl
    raw_ref_vol := p2_ref_vol
    pattern_name := "Pattern 2"

// ====================================
// 6. GENERIC TRADE EXECUTION
// ====================================

// --- Adjust Entry for Psych Levels ---
float final_entry = raw_entry
if use_psych_filter and not na(raw_entry)
    float next_whole = math.ceil(raw_entry)
    float next_half = math.ceil(raw_entry * 2.0) / 2.0
    float nearest_res = math.min(next_whole, next_half)
    float dist = nearest_res - raw_entry
    if dist > 0 and dist < (raw_entry * 0.005)
        final_entry := nearest_res + syminfo.mintick

float total_commission_cost = commission_per_share * trade_qty

// --- Exit Management ---
if in_trade
    if low <= sl_price
        cnt_loss := cnt_loss + 1
        float gross_loss = (entry_price - sl_price) * trade_qty
        net_profit := net_profit - (gross_loss + total_commission_cost)
        in_trade := false
        last_exit_bar := bar_index
        status_txt := "Stop Loss Hit"
        if not na(active_trade_label)
            label.set_text(active_trade_label, "Lose\n" + trade_pattern)
            label.set_color(active_trade_label, color.red)
            label.set_style(active_trade_label, label.style_label_down)
            label.set_yloc(active_trade_label, yloc.abovebar)

    else if high >= tp_price
        cnt_win := cnt_win + 1
        float gross_profit = (tp_price - entry_price) * trade_qty
        net_profit := net_profit + (gross_profit - total_commission_cost)
        in_trade := false
        last_exit_bar := bar_index
        status_txt := "Take Profit Hit"
        if not na(active_trade_label)
            label.set_text(active_trade_label, "Win\n" + trade_pattern)
            label.set_color(active_trade_label, color.green)

// --- Entry Logic (Generic Filters applied to Final Signal) ---

// 1. Breakout Condition
bool cond_breakout = high >= final_entry

// 2. Volume Projection
float volume_check = volume
if barstate.isrealtime
    int time_elapsed = timenow - time
    int time_total = time_close - time
    if time_elapsed > 0 and time_total > 0
        volume_check := volume * (time_total / time_elapsed)

// 3. Generic Filter Checks
bool cond_green = close > open
bool cond_no_trade = not in_trade
bool cond_cooldown = (bar_index - last_exit_bar) > cooldown
bool cond_macd = macd_line > 0 and macd_line > signal_line
bool cond_vwap = close > vwap_val

// 4. Pattern Specific Volume Check (Only applies if P1 triggered)
bool cond_p1_vol = true 
if p1_found and p1_use_breakout_vol
    cond_p1_vol := volume_check > raw_ref_vol

// 5. TP Validity Check (HOD)
float calc_risk = final_entry - raw_sl
if calc_risk <= 0
    calc_risk := syminfo.mintick * 10
float projected_tp = final_entry + (calc_risk * 2)
bool cond_tp_valid = projected_tp <= daily_high

// --- MASTER BUY TRIGGER ---
bool trigger_buy = pattern_detected and 
     cond_breakout and 
     (not use_green_bar or cond_green) and 
     (not use_no_trade or cond_no_trade) and 
     (not use_cooldown or cond_cooldown) and 
     (not use_macd_filter or cond_macd) and
     (not use_vwap_filter or cond_vwap) and
     (not use_hod_filter or cond_tp_valid) and
     cond_p1_vol // Applies pattern-specific volume rule

if time < lookback_start_time
    trigger_buy := false

if trigger_buy
    in_trade := true
    status_txt := pattern_name + " ENTRY"
    trade_pattern := pattern_name // Save the pattern name for this trade
    entry_price := final_entry
    sl_price := raw_sl
    
    // Recalculate Risk/TP based on confirmed entry
    float risk = entry_price - sl_price
    if risk <= 0
        risk := syminfo.mintick * 10
    tp_price := entry_price + (risk * 2)

    // Visuals
    l_entry := line.new(x1=bar_index, y1=entry_price, x2=bar_index, y2=entry_price, color=color.blue, width=2, style=line.style_solid)
    l_tp := line.new(x1=bar_index, y1=tp_price, x2=bar_index, y2=tp_price, color=color.green, width=2)
    l_sl := line.new(x1=bar_index, y1=sl_price, x2=bar_index, y2=sl_price, color=color.red, width=2)
    b_risk := box.new(left=bar_index, top=tp_price, right=bar_index, bottom=sl_price, bgcolor=color.new(color.teal, 85), border_color=color.teal)

    active_trade_label := label.new(
         x=bar_index, 
         y=low, 
         text="BUY\n" + pattern_name, 
         color=color.blue, 
         textcolor=color.white, 
         style=label.style_label_up, 
         yloc=yloc.belowbar,
         text_formatting=text.format_bold
    )
    
    array.push(weekly_lines, l_entry)
    array.push(weekly_lines, l_tp)
    array.push(weekly_lines, l_sl)
    array.push(weekly_boxes, b_risk)
    array.push(weekly_labels, active_trade_label)

if in_trade or (bar_index == last_exit_bar)
    line.set_x2(l_entry, bar_index)
    line.set_x2(l_tp, bar_index)
    line.set_x2(l_sl, bar_index)
    box.set_right(b_risk, bar_index)

// ====================================
// 7. DASHBOARD (SAME VISUALS)
// ====================================

var table dashboard = table.new(position.top_right, 4, 4, color.new(color.black, 80), color.white, 1, color.white, 1)

if barstate.islast
    string d_tp = na(tp_price) ? "0.00" : str.tostring(tp_price, format.mintick)
    string d_entry = na(entry_price) ? "0.00" : str.tostring(entry_price, format.mintick)
    string d_sl = na(sl_price) ? "0.00" : str.tostring(sl_price, format.mintick)

    // INCREASED TEXT SIZE HERE FOR HEADERS
    table.cell(dashboard, 0, 0, "Perf (" + str.tostring(lookback_days) + "d | " + str.tostring(trade_qty) + "s)", text_color=color.white, text_size=size.normal, text_formatting=text.format_bold)
    table.cell(dashboard, 1, 0, "Trade Values", text_color=color.white, text_size=size.normal, text_formatting=text.format_bold)
    table.cell(dashboard, 3, 0, "Status", text_color=color.white, text_size=size.normal, text_formatting=text.format_bold)

    string wl_text = str.format("{0} W | {1} L", cnt_win, cnt_loss)
    table.cell(dashboard, 0, 1, wl_text, text_color=color.white)
    table.cell(dashboard, 1, 1, "TP:", text_color=color.green, text_halign=text.align_left)
    table.cell(dashboard, 2, 1, d_tp, text_color=color.white, text_halign=text.align_right)
    
    color stat_col = in_trade ? color.yellow : (status_txt == "Take Profit Hit" ? color.green : color.white)
    bool cooling_down = not in_trade and (bar_index - last_exit_bar) <= cooldown
    string display_status = cooling_down ? "Cooldown..." : status_txt
    table.cell(dashboard, 3, 1, display_status, text_color=stat_col)
    
    color profit_bg = net_profit >= 0 ? color.new(color.green, 60) : color.new(color.red, 60)
    string profit_txt = str.tostring(net_profit, format.mintick) + "$"
    table.cell(dashboard, 0, 2, profit_txt, bgcolor=profit_bg, text_color=color.white)
    
    table.cell(dashboard, 1, 2, "Entry:", text_color=color.blue, text_halign=text.align_left)
    table.cell(dashboard, 2, 2, d_entry, text_color=color.white, text_halign=text.align_right)

    table.cell(dashboard, 1, 3, "SL:", text_color=color.red, text_halign=text.align_left)
    table.cell(dashboard, 2, 3, d_sl, text_color=color.white, text_halign=text.align_right)

    table.merge_cells(dashboard, 1, 0, 2, 0)
    table.merge_cells(dashboard, 0, 2, 0, 3)
    table.merge_cells(dashboard, 3, 1, 3, 3)
